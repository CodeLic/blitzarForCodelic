<template>
  <q-table
    class="blitz-table"
    v-bind="quasarProps"
    :selected.sync="cSelected"
    :pagination.sync="pagination"
  >
    <template v-slot:top v-if="usesTopSlot">
      <slot name="above-nav-row" />
      <div class="blitz-table__nav-row">
        <slot name="top-left">
          <div class="q-table__title" v-if="title">{{ title }}</div>
        </slot>
        <slot name="top-right">
          <BlitzBtn
            v-for="btn in cActionButtons"
            :key="btn.btnLabel"
            v-bind="btn"
            v-on="btn.events"
          />
        </slot>
      </div>
      <slot name="above-table" />
    </template>
    <!-- Pass on all scoped slots -->
    <template
      v-for="slot in Object.keys($scopedSlots).filter(slot => !slot.includes('top'))"
      v-slot:[slot]="scope"
    >
      <slot :name="slot" v-bind="scope" />
    </template>

    <!-- <template v-slot:header="headerProps">
      <q-tr :props="headerProps">
        <q-th auto-width />
        <q-th v-for="col in headerProps.cols" :key="col.name" :props="headerProps">
          {{ col.label }}
        </q-th>
      </q-tr>
    </template>-->
    <template v-slot:body="rowProps">
      <!--
        BlitzRow.vue's only purpose is:
        (1) to create `BlitzFormSimulatedContext` including the `fieldInput` function (required for BlitzCells to make sure the schema's can access this function)
        (2) to set up the @row-input listener which is to be triggered whenever `fieldInput` is executed
        (3) add row classes; style and their respective props
      -->
      <BlitzRow
        :q-table-row-props="rowProps"
        :schema="schemaColumns"
        :value="rowProps.row"
        :id="rowProps.row.id"
        :row-style="rowStyle"
        :row-classes="rowClasses"
        mode="raw"
        @row-input="
          ({ rowId, fieldId, value, origin }) => onInputCell(rowId, fieldId, value, origin)
        "
        v-slot="BlitzFormSimulatedContext"
      >
        <q-td v-if="selectionMode" auto-width>
          <div class="flex flex-center">
            <q-checkbox :dense="true" v-model="rowProps.selected" />
          </div>
        </q-td>
        <q-td
          v-for="blueprint in schemaColumns"
          :key="blueprint.id"
          :props="rowProps"
          @click.native="e => onRowClick(e, rowProps.row)"
        >
          <!-- requires row, blueprint, value -->
          <BlitzCell
            v-bind="merge(BlitzFormSimulatedContext, blueprint)"
            :value="getProp(BlitzFormSimulatedContext.formData, blueprint.id)"
            @input="(val, origin) => onInputCell(rowProps.row.id, blueprint.id, val, origin)"
          />
        </q-td>
      </BlitzRow>
    </template>
    <!-- Grid item -->
    <template v-slot:item="gridItemProps">
      <slot name="item" v-bind="gridItemProps">
        <q-card
          :class="
            flattenArray([
              'blitz-table__grid-item',
              gridItemProps.selected ? 'selected' : [],
              evaluate(cardClass, gridItemProps),
            ])
          "
          :style="evaluate(cardStyle, gridItemProps)"
          @click="e => onRowClick(e, gridItemProps.row, 'grid', gridItemProps)"
        >
          <BlitzForm
            :key="JSON.stringify(gridItemProps.row)"
            :value="gridItemProps.row"
            :id="gridItemProps.row.id"
            v-bind="gridBlitzFormProps"
            @field-input="
              ({ id: fieldId, value, origin }) =>
                onInputCell(gridItemProps.row.id, fieldId, value, origin)
            "
          />
        </q-card>
      </slot>
    </template>
  </q-table>
</template>

<style lang="sass">
// $
@import '../index.sass'

.blitz-table
  display: flex
  flex-direction: column
  th
    white-space: pre
  .q-table__top
    display: flex
    flex-wrap: nowrap
    flex-direction: column
    align-items: stretch
.blitz-table__nav-row
  display: grid
  justify-content: stretch
  align-content: start
  align-items: center
  grid-gap: $md
  grid-auto-flow: column
  grid-template-columns: 1fr
.blitz-table__grid-item
  margin: $sm
  padding: $md
  transition: all 200ms
  .blitz-field__sub-label
    display: none
  &.selected
    background: #efefef
    transform: scale(0.9)
</style>

<script>
import { getProp } from 'path-to-prop'
import { merge } from 'merge-anything'
import { flattenArray } from 'flatten-anything'
import { isPlainObject, isFunction } from 'is-what'
import { QTable, QTd, QCheckbox, QCard, QIcon, QInput } from 'quasar'
import { BlitzBtn, BlitzForm } from '@blitzar/form'
import BlitzRow from './BlitzRow.vue'
import BlitzCell from './BlitzCell.vue'
import schemaToQTableColumns from '../helpers/schemaToQTableColumns.js'

export default {
  name: 'BlitzTable',
  inheritAttrs: false,
  components: {
    QTable,
    QTd,
    QCheckbox,
    QCard,
    QInput,
    QIcon,
    BlitzBtn,
    BlitzForm,
    BlitzRow,
    BlitzCell,
  },
  desc: `BlitzForms is a peer dependency!`,
  props: {
    // BlitzTable props:
    /**
     * The schema for the columns you want to generate. (BlitzForm schema format)
     * @type {{[key in string]: any}[]}
     * @example [{ id: 'nameFirst', label: 'First Name', component: 'input' }, { id: 'nameLast', label: 'Last Name', component: 'input' }]
     * @category column
     */
    schemaColumns: { type: Array, required: true },
    /**
     * The schema for the grid cards you want to generate. (BlitzForm schema format)
     * @category column
     */
    schemaGrid: { type: [Array, Object] },
    /**
     * Rows of data to display. Use `rows` instead of the QTables `data`. Renamed for clarity.
     * @type {{[key in string]: any}[]}
     * @example [{ nameFirst: 'Eleanor', nameLast: 'Shellstrop' }, { nameFirst: 'Chidi', nameLast: 'Anagonye' }]
     * @category model
     */
    rows: { type: Array, required: true },
    /**
     * Action buttons to add to the table. These can be pre-set buttons you can add by passing a string, or custom ones by passing an object with {label, handler}.
     *
     * Preset buttons include:
     * - 'add'
     * - 'grid'
     * - 'selection:duplicate' (this just does `$emit('duplicate', selectionArray)`, you must implement your own logic.
     * @example ['add', 'grid', { btnLabel: 'do it', events: { click: console.log } }]
     * @category content
     */
    actionButtons: { type: Array, default: () => ['grid'] },
    /**
     * The BlitzForm options you want to use for the grid cards.
     *
     * Please note:
     * - The 'schema' should be set via the 'schemaGrid' prop.
     * - 'value' and 'id' are set automatically.
     * - These are the default values, but they can be overridden: `{ actionButtons: [] }`
     * - See the documentation of BlitzForm for more information on available props.
     * @category column
     */
    gridBlitzFormOptions: { type: Object, default: () => ({}) },
    /**
     * The text used in the UI, eg. the 'add new record' buttons etc... Pass an object with keys: ....
     * @category content
     */
    lang: { type: Object, default: () => ({ add: 'Add new', duplicate: 'Duplicate' }) }, // when updating this, be sure to also update "innerLang"
    /**
     * Check the description at BlitzRow.vue
     * @category style
     */
    rowClasses: {},
    /**
     * Check the description at BlitzRow.vue
     * @category style
     */
    rowStyle: {},
    // Inherited props used here:
    /**
     * @category inherited prop
     */
    grid: { type: Boolean, default: false },
    /**
     * @category inherited prop
     */
    selected: { type: Array, default: () => [] },
    /**
     * @category inherited prop
     */
    cardClass: {},
    /**
     * @category inherited prop
     */
    cardStyle: {},
    // Inherited props with different defaults:
    // Modified inherited props:
    /**
     * Use `rows` instead of the QTables `data`. Renamed for clarity.
     * @category modified prop
     */
    data: { type: Array },
    /**
     * Do not use this! Use `schemaColumns` instead. This is the prop QTable uses to define its columns. BlitzTable uses `schemaColumns` instead.
     * @category modified prop
     */
    columns: {},
    /**
     * A title to be placed above your table.
     * @category modified prop
     */
    title: { type: String },
    /**
     * This is fixed to `id` in a BlitzTable and cannot be changed.
     * @category modified prop
     */
    rowKey: {},
  },
  data() {
    const { lang, grid, selected } = this
    // merge user provided lang onto defaults
    const innerSelected = selected
    // when updating this, be sure to also update the "lang" prop
    const innerLang = merge({ add: 'Add new', duplicate: 'Duplicate' }, lang)
    const innerGrid = grid
    // const innerFilter = filter
    return {
      // innerFilter,
      innerSelected,
      innerLang,
      innerGrid,
      defaultPagination: {
        rowsPerPage: 10,
      },
    }
  },
  watch: {
    grid(newValue) {
      this.innerGrid = newValue
    },
    selected(newValue) {
      this.innerSelected = newValue
    },
  },
  computed: {
    selectionMode() {
      const { quasarProps } = this
      return quasarProps.selection === 'single' || quasarProps.selection === 'multiple'
    },
    pagination: {
      get() {
        return this.quasarProps.pagination || this.defaultPagination
      },
      set(newPagination) {
        if (this.quasarProps.pagination) {
          return this.$emit('update:pagination', newPagination)
        }
        this.defaultPagination = newPagination
      },
    },
    usesTopSlot() {
      const { title, cActionButtons, $scopedSlots: slot } = this
      return (
        title ||
        cActionButtons.length ||
        slot['above-table'] ||
        slot['above-nav-row'] ||
        slot['top-left'] ||
        slot['top-right']
      )
    },
    quasarProps() {
      return merge(this.$attrs, {
        // Quasar props with modified behavior:
        data: this.rows,
        columns: this.cColumns,
        rowKey: 'id',
        grid: this.innerGrid,
        // Quasar props with modified defaults:
        // filter: this.$attrs.filter || this.innerFilter,
        // Quasar props just to pass:
      })
    },
    gridBlitzFormProps() {
      const { gridBlitzFormOptions, schemaGrid } = this
      const defaults = {
        actionButtons: [],
        mode: 'raw',
        schema: schemaGrid,
      }
      return merge(defaults, gridBlitzFormOptions)
    },
    cSelected: {
      get() {
        return this.innerSelected
      },
      set(val) {
        this.innerSelected = val
        this.$emit('update:selected', val)
      },
    },
    cColumns() {
      return schemaToQTableColumns(this.schemaColumns)
    },
    cActionButtons() {
      const {
        actionButtons,
        innerLang,
        tapAdd,
        tapDuplicate,
        cSelected,
        innerGrid,
        enableGrid,
        disableGrid,
        schemaGrid,
      } = this
      const blitzTableContext = this
      return actionButtons
        .map((btn) => {
          if (btn === 'grid' && schemaGrid) {
            // return // 以下の機能は未完成
            return innerGrid
              ? { icon: 'view_list', flat: true, events: { click: disableGrid } }
              : { icon: 'view_module', flat: true, events: { click: enableGrid } }
          }
          if (cSelected.length) {
            if (btn === 'selection:duplicate') {
              return {
                btnLabel: innerLang['duplicate'],
                push: true,
                events: { click: tapDuplicate },
              }
            }
          }
          if (!cSelected.length) {
            if (btn === 'add') {
              return { btnLabel: innerLang['add'], push: true, events: { click: tapAdd } }
            }
          }
          if (isPlainObject(btn)) {
            if (!isPlainObject(btn.events)) return btn
            const { click } = btn.events
            if (isFunction(click)) btn.events.click = (val) => click(val, blitzTableContext)
            return btn
          }
        })
        .filter((btn) => isPlainObject(btn))
    },
  },
  methods: {
    evaluate(prop, rowProps) {
      if (!isFunction(prop)) return prop
      return prop(rowProps.row, rowProps, this)
    },
    flattenArray,
    getProp,
    merge,
    enableGrid() {
      this.innerGrid = true
    },
    disableGrid() {
      this.innerGrid = false
    },
    tapAdd() {
      this.$emit('add')
    },
    tapDuplicate() {
      this.$emit('duplicate', this.cSelected)
    },
    onRowClick(event, rowData, origin, gridItemProps) {
      const { selectionMode } = this
      if (origin === 'grid' && selectionMode) {
        gridItemProps.selected = !gridItemProps.selected
      }
      this.$emit('row-click', event, rowData)
    },
    onInputCell(rowId, colId, value, origin) {
      this.$emit('input-cell', { rowId, colId, value, origin })
    },
  },
}
</script>
